{
    "collab_server" : "",
    "contents" : "#' Calcul.mat.bt\n#'\n#' @return\n#' @export\n#' @param ww the pattern you want to recognize in the name of the files you want to used to calculate variables.\n#' @param papa indicate the value of the interval of resolution in Windendro.\n#' @param subst1 where to start in the substring of the file name to determined the identification code\n#' @param subst2 where to stop in the substring  of the file name to determined the identification code\n#' @examples\ncalcul.mat.bt<-function(ww = \"dat\", papa , subst1 , subst2)\n{\n  par(mfrow=c(1,1))\n  liste.profils <- objects(pattern = ww ,pos=1)\n  matrix.resultats <- NULL        #matrice des resultats\n  vec <- NULL     #vecteur forme a chaque boucle : donnees par cerne\n  pas <- papa #0.006350 #distance entre deux points de mesure successifs windendro\n  #attention, ne pas oublier de l'adapter en fonction de la fenetre du mdm ou de la definition de Windendro\n  #microdensitometre optique 0.024, mdm Windendro 0.025..., voire encore moins si scan haute r?solution\n  #boucle \"arbre par arbre\" (a adapter pour 2 profils par arbre...)\n\n  #pac<-read.table(file=\"prov_SALA.txt\",header=TRUE)\n\n  for (i in 1:length(liste.profils))\n  {\n    #DEPART!\n    print(i)\n    nom<-liste.profils[i]\n    print(nom)\n    x <- get(nom, pos = 1) #profil\n    millesime <- max(as.numeric(x$millesimes))    #millesime VERIFIER\n    lim.cernes <- x$lim.cernes    #limites de cerne\n    lim.bibtbf <- x$lim.bibtbf     #decoupe selon la limite BI-BT-BF\n    plot(x$profil,pch=\".\")\n    abline(v=lim.cernes,col = \"Red\")\n    abline(v=lim.bibtbf)\n    text(lim.cernes-(c(lim.cernes,NA)-c(0,lim.cernes))/2,max(x$profil),as.character(x$millesimes),cex=0.7)\n    nn <- length(lim.cernes)\n    num.cernes<-1:nn\n    text(lim.cernes-(c(lim.cernes,NA)-c(0,lim.cernes))/2,0.9*max(x$profil),as.character(num.cernes),cex=0.8)\n    #readline()\n    mm <- length(lim.bibtbf)\n    profil <- x$profil\n    #boucle \"cerne par cerne dans l'arbre\"\n    toutes.lim.cernes<-c(1,lim.cernes)\n    lim.bibtbf1 <- lim.bibtbf[1:length(lim.bibtbf) %% 2 == 1] # on sélectionne les limite de BT inférieurs\n    lim.bibtbf2 <- lim.bibtbf[1:length(lim.bibtbf) %% 2 == 0] # on sélectionne les limite de BT supérieurs\n\n    for (j in num.cernes)\n    {\n      lim1 <- toutes.lim.cernes[j]\n      lim2 <- toutes.lim.cernes[j + 1]\n      l.bibtbf1 <- lim.bibtbf1[j]\n      l.bibtbf2 <- lim.bibtbf2[j]\n      Lo <- round((length(profil[lim1:lim2])) * pas, 4) #largeur de cerne en mm\n      Li <- round((length(profil[lim1:l.bibtbf1])) * pas, 4) #largeur du bi en mm type Nancy\n      Lt <- round((length(profil[l.bibtbf1:l.bibtbf2])) * pas, 4) #largeur du bt en mm type Nancy\n      Lf <- round(Lo - (Li+Lt), 4) #largeur du bf en mm\n      Do <- round(mean((profil[lim1:lim2]), na.rm = T), 3) #densite moyenne de cerne\n      Di <- round(mean((profil[lim1:l.bibtbf1]), na.rm = T), 3) #densite moyenne bi type Nancy\n      Dt <- round(mean((profil[l.bibtbf1:l.bibtbf2]), na.rm = T), 3) #densite moyenne bt\n      Df <- round(mean((profil[l.bibtbf2:lim2]), na.rm = T), 3) #densite moyenne bf\n      Mi <- round(min((profil[lim1:lim2]), na.rm = T), 3) #densite min cerne\n      Ma <- round(max((profil[lim1:lim2]), na.rm = T), 3) #densite max cerne\n      profil.sans.NA <- profil[lim1:lim2][!is.na(profil[lim1:lim2])]\n      Eo <- round(sqrt(var(profil.sans.NA)), 3) #?cart type de densit? intra-cerne\n      Et <- round(sqrt(var(profil[l.bibtbf1:l.bibtbf2])), 3) #?cart type de densit? intra-bt\n      Ei <- round(sqrt(var(profil[lim1:l.bibtbf1])), 3) #?cart type de densit? intra-bi\n      Ef <- round(sqrt(var(profil[l.bibtbf2:lim2])), 3) #?cart type de densit? intra-bf\n      Co <- Ma - Mi # contraste de densit? intra-cerne\n      annee <- x$millesimes[j] #annee du cerne\n      #prov<-pac[i,\"prov\"]\n      vec <- data.frame( substring(liste.profils[i] , subst1 , subst2 ), annee, j, Lo, Li, Lt, Lf, Do, Di, Dt, Df, Mi, Ma, Eo, Ei, Et, Ef, Co) #cas particulier ?\n      #ADAPTER le substring !\n      colnames(vec) <- c(\"code\", \"ye\",\"ce\", \"Lo\", \"Li\", \"Lt\", \"Lf\", \"Do\", \"Di\", \"Dt\", \"Df\", \"Mi\", \"Ma\", \"Eo\", \"Ei\", \"Et\", \"Ef\", \"Co\")\n      matrix.resultats <- rbind(matrix.resultats, vec)\n      #sauvegarde\n      assign(\"matmdm_BT\", matrix.resultats, pos = 1, immediate = T)\n    }\n  }\n}\n\n",
    "created" : 1494589203401.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "285686938",
    "id" : "E6C2A61A",
    "lastKnownWriteTime" : 1516617859,
    "last_content_update" : 1516617859245,
    "path" : "D:/thchauvin/Doc-INRA/Stats R/Packages/MicrodensiteR/R/calcul.mat.bt.r",
    "project_path" : "R/calcul.mat.bt.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 14,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}