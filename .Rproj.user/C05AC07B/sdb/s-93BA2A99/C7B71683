{
    "collab_server" : "",
    "contents" : "#' K.bibf.tot\n#'\n#' @return\n#' @export\n#' @details position the limite between earlywood and latewood. Create a new object adding a \"x\" at the beginning of the original name\n#' @param tt the pattern you want to recognize in the name of the files you want to to work on.\n#' @examples\nk.bibf.tot<-function(tt = \"dat\")\n  #source(\"k.bibf.R\");k.bibf.R()\n{\n  par(mfrow=c(1,1))\n  liste.profils<-objects(pattern=tt,pos=1)\n\n  for (i in 1:length(liste.profils))\n  {\n    xx<-get(liste.profils[i],pos=1)\n\n    profil<-liste.profils[i]\n    cat(profil,\"\\n\")\n\n    x<-xx$profil\n    x<-x[!is.na(x)]\n    lim.cernes<-xx$limites\n    lim.cernes<-lim.cernes[!is.na(lim.cernes)]\n    lim.cernes.x<-lim.cernes\n    nbr.cernes<-length(lim.cernes)\n    lim.cernes.x<-c(1,lim.cernes)\n    lim.cernes<-c(1,lim.cernes)\n    nbr.limites<-nbr.cernes+1\n\n    #                           PROFIL DE DEPART:\n\n    #                      LISSAGE, LIMITES \"CLASSIQUES\" :\n    #                      ******************************\n    z<-x\n    profil.lisse<-NULL\n    lim.bibf.Nancy<-NULL\n    # On travaille cerne par cerne :\n    for (k in 1:(nbr.cernes))\n    {\n      cat(k,\"\\n\")\n      #decoupage du profil en cernes :\n      #*******************************\n      profil.cerne<-x[(lim.cernes.x[k]):(lim.cernes.x[k+1])]\n      l<-length(profil.cerne)\n      NA.debut<-length(profil.cerne[1:(l/2)][is.na(profil.cerne[1:(l/2)])]) #nbre de NA en debut de profil\n      NA.fin<-length(profil.cerne[(l/2):l][is.na(profil.cerne[(l/2):l])])\n      profil.cerne.0.NA<-profil.cerne[!is.na(profil.cerne)]\n\n      #limites Nancy :\n      #****************\n      ttt<-0.01\n      aaa<-1\n      while (ttt<0.1)\n      {\n        y<-profil.cerne.0.NA\n        y<-y[aaa:(length(y))]\n        aaa<-aaa+1\n        tt<-seq(along=y)\n        lll<-length(y)\n        amax<-tt[y==max(y)] #abcisse du max\n        ttt<-amax/lll\n        if (length(amax)>1) {amax<-amax[1]}\n        y<-y[1:(amax)]\n        tt<-seq(along=y)\n        amin<-tt[y==min(y)] #abcisse du min\n        if (length(amin)>1) {amin<-amin[length(amin)]}\n        y<-y[amin:(length(y))]\n        tt<-seq(along=y)\n        alN<-tt[(y-(max(y)+min(y))/2)^2==min((y-(max(y)+min(y))/2)^2)]\n        if (length(alN>1)) {alN<-alN[1]}\n        alN<-lim.cernes[k]+amin+alN\n        #lim.bibf.Nancy<-c(lim.bibf.Nancy,alN)\n      }\n      lim.bibf.Nancy<-c(lim.bibf.Nancy,alN)\n    }\n\n    #           Affichage du profil complet avec l'emplacement des limites ponctuelles\n    #           **********************************************************************\n\n\n    plot(x,type=\"n\",xlab=\"Longueur (X24 microns)\",ylab=\"densite (g/dm3)\")\n    lines(x)\n    mtext(\"Definition des limites bois initial-bois final\",3,outer=T,cex=1.4)\n    points(lim.bibf.Nancy,x[lim.bibf.Nancy],type=\"p\",pch=0,cex=1)\n    abline(v=lim.bibf.Nancy,lty=2)\n    abline(v=lim.cernes,lty=1)\n    xxx<-length(x)/50\n    yyy<-min(x,na.rm=T)+0.1*min(x,na.rm=T)\n\n    #readline()\n    #                     SORTIE: profil avec limites\n    #                     ***************************\n\n\n    #controle\n    if (length(lim.bibf.Nancy)!=nbr.cernes)\n    {\n      cat(\"controle!\",liste.profils[[i]])\n      readline()\n    }\n    #Profil complet:\n    cat(paste(length(lim.cernes),\"// \"))\n    sortie<-list(length=4) #au lieu de 5 : pas de profil\n    sortie[[1]]<-xx$profil #lim de cernes\n    sortie[[2]]<-xx$limites[!is.na(xx$limites)]\n    sortie[[3]]<-sort(lim.bibf.Nancy) #lim bibf type Nancy (moy min max) ATTENTION en 5 depuis les epiceas Geniality\n    sortie[[4]]<-xx$millesimes[!is.na(xx$millesimes)]\n    names(sortie)<-c(\"profil\",\"lim.cernes\",\"lim.bibf\",\"millesimes\")#\n    cat(\"Suivant?\")\n    #readline()\n    assign(paste(\"x\",profil,sep=\"\"),sortie,pos=1,immediate=T) #changer\n\n    cat(\"\\nFIN:\\n\")\n\n    #cat(\"\\nTaper <Entree> pour continuer, x pour arreter\\n\")\n    #zzz<-readline()\n    zzz<-\"bouclage\"\n    if (zzz==\"x\") {stop()}\n\n  } #fin de boucle \"automatisation de la lecture des profils d'un .Data\"\n\n} #fin de fonction\n\n",
    "created" : 1487058439851.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2334592390",
    "id" : "C7B71683",
    "lastKnownWriteTime" : 1516624897,
    "last_content_update" : 1516624897398,
    "path" : "D:/thchauvin/Doc-INRA/Stats R/Packages/MicrodensiteR/R/k.bibf.tot.R",
    "project_path" : "R/k.bibf.tot.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}