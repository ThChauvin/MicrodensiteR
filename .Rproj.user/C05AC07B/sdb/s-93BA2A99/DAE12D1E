{
    "collab_server" : "",
    "contents" : "#' Calcul.mat\n#'\n#' @return\n#' @export\n#' @param ww the pattern you want to recognize in the name of the files you want to used to calculate variables.\n#' @param papa indicate the value of the interval of resolution in Windendro.\n#' @param subst1 where to start in the substring of the file name to determined the identification code\n#' @param subst2 where to stop in the substring  of the file name to determined the identification code\n#' @examples\ncalcul.mat<-function(ww = \"dat\", papa, subst1 , subst2 )\n{\n  par(mfrow=c(1,1))\n  liste.profils <- objects(pattern = ww ,pos=1)\n  matrix.resultats <- NULL        #matrice des resultats\n  vec <- NULL     #vecteur forme a chaque boucle : donnees par cerne\n  pas <- papa\nfor (i in 1:length(liste.profils))\n\t\t{\n\t\t#DEPART!\n    print(i)\n\t\tnom<-liste.profils[i]\nprint(nom)\n    x <- get(nom, pos = 1) #profil\n    millesime <- max(as.numeric(x$millesimes))    #millesime VERIFIER\n    lim.cernes <- x$lim.cernes    #limites de cerne\n    lim.bibf1 <- x$lim.bibf     #decoupe selon la limite BI-BF Nancy\nplot(x$profil,pch=\".\")\nabline(v=lim.cernes)\nabline(v=lim.bibf1)\ntext(lim.cernes-(c(lim.cernes,NA)-c(0,lim.cernes))/2,max(x$profil),as.character(x$millesimes),cex=0.7)\n     nn <- length(lim.cernes)\nnum.cernes<-1:nn\ntext(lim.cernes-(c(lim.cernes,NA)-c(0,lim.cernes))/2,0.9*max(x$profil),as.character(num.cernes),cex=0.8)\n#readline()\n     mm <- length(lim.bibf1)\n     profil <- x$profil\n#boucle \"cerne par cerne dans l'arbre\"\ntoutes.lim.cernes<-c(1,lim.cernes)\n      for (j in num.cernes)\n     {\n     lim1 <- toutes.lim.cernes[j]\n     lim2 <- toutes.lim.cernes[j + 1]\n     l.bibf1 <- lim.bibf1[j]\n     Lo <- round((length(profil[lim1:lim2])) * pas, 4) #largeur de cerne en mm\n     Li <- round((length(profil[lim1:l.bibf1])) * pas, 4) #largeur du bi en mm type Nancy\n     Lf <- round(Lo - Li, 4) #largeur du bf en mm\n     Do <- round(mean((profil[lim1:lim2]), na.rm = T), 3) #densite moyenne de cerne\n     Di <- round(mean((profil[lim1:l.bibf1]), na.rm = T), 3) #densite moyenne bi type Nancy\n     Df <- round(mean((profil[l.bibf1:lim2]), na.rm = T), 3) #densite moyenne bf\n     Mi <- round(min((profil[lim1:lim2]), na.rm = T), 3) #densite min cerne\n     Ma <- round(max((profil[lim1:lim2]), na.rm = T), 3) #densite max cerne\n     profil.sans.NA <- profil[lim1:lim2][!is.na(profil[lim1:lim2])]\n     Eo <- round(sqrt(var(profil.sans.NA)), 3) #?cart type de densit? intra-cerne\n     Ei <- round(sqrt(var(profil[lim1:l.bibf1])), 3) #?cart type de densit? intra-bi\n     Ef <- round(sqrt(var(profil[l.bibf1:lim2])), 3) #?cart type de densit? intra-bf\n     Co <- Ma - Mi # contraste de densit? intra-cerne\n     annee <- x$millesimes[j] #annee du cerne\n     #prov<-pac[i,\"prov\"]\n     vec <- data.frame( substring(liste.profils[i],subst1,subst2 ), annee, j, Lo, Li, Lf, Do, Di, Df, Mi, Ma, Eo, Ei, Ef, Co) #cas particulier ?\n#ADAPTER le substring !\n     colnames(vec) <- c(\"code\", \"ye\",\"ce\", \"Lo\", \"Li\", \"Lf\", \"Do\", \"Di\", \"Df\", \"Mi\", \"Ma\", \"Eo\", \"Ei\", \"Ef\", \"Co\")\n     matrix.resultats <- rbind(matrix.resultats, vec)\n    # matrix.resultats <- data.frame(matrix.resultats[,c(1,as.numeric(as.character(2:15)))])\n    assign(\"matmdm\", matrix.resultats, pos = 1, immediate = T)\n\n    }\n    }\n}\n\n",
    "created" : 1487058434621.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "45934775",
    "id" : "DAE12D1E",
    "lastKnownWriteTime" : 1516618104,
    "last_content_update" : 1516618104670,
    "path" : "D:/thchauvin/Doc-INRA/Stats R/Packages/MicrodensiteR/R/calcul.mat.r",
    "project_path" : "R/calcul.mat.r",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}