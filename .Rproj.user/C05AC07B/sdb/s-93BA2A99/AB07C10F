{
    "collab_server" : "",
    "contents" : "#' K.bibtbf\n#'\n#' @return\n#' @export\n#' @details position the limite between earlywood, transition-wood and latewood. Create a new object adding a \"t\" at the beginning of the original name.\n#' @param tt the pattern you want to recognize in the name of the files you want to work on.\n#' @examples\nk.bibtbf<-function(tt = \"dat\")\n  #source(\"k.bibf.R\");k.bibf.R()\n{\n  par(mfrow=c(1,1))\n  liste.profils<-objects( pattern = tt ,pos=1)\n\n  for (i in 1:length(liste.profils))\n  {\n    xx<-get(liste.profils[i],pos=1)\n\n    profil<-liste.profils[i]\n    cat(profil,\"\\n\")\n\n    x<-xx$profil\n    x<-x[!is.na(x)]\n    lim.cernes<-xx$limites\n    lim.cernes<-lim.cernes[!is.na(lim.cernes)]\n    lim.cernes.x<-lim.cernes\n    nbr.cernes<-length(lim.cernes)\n    lim.cernes.x<-c(1,lim.cernes)\n    lim.cernes<-c(1,lim.cernes)\n    nbr.limites<-nbr.cernes+1\n\n    #                           PROFIL DE DEPART:\n\n    #                      LISSAGE, LIMITES \"CLASSIQUES\" :\n    #                      ******************************\n    z<-x\n    profil.lisse<-NULL\n    lim.bibf.Nancy<-NULL\n    # On travaille cerne par cerne :\n    for (k in 1:(nbr.cernes))\n    {\n      cat(k,\"\\n\")\n      #decoupage du profil en cernes :\n      #*******************************\n      profil.cerne <- x[(lim.cernes.x[k]):(lim.cernes.x[k+1])]\n      l <- length(profil.cerne)\n      NA.debut <- length(profil.cerne[1:(l/2)][is.na(profil.cerne[1:(l/2)])]) #nbre de NA en debut de profil\n      NA.fin <- length(profil.cerne[(l/2):l][is.na(profil.cerne[(l/2):l])])  #nbre de NA en fin de profil\n      profil.cerne.0.NA<-profil.cerne[!is.na(profil.cerne)]\n\n      #limites Nancy :\n      #****************\n      # ttt<-0.01\n      aaa<-1\n      # while (ttt<0.1)\n      # {\n      y <- profil.cerne.0.NA\n      y <- y[aaa:(length(y))]\n      # aaa<-aaa+1\n      tt <- seq(along=y)\n      lll <- length(y)\n      amax <- tt[y==max(y)] #abcisse du max\n      ttt <- amax/lll\n      if (length(amax)>1) {amax<-amax[1]}\n      y <- y[1:(amax)]\n      tt <- seq(along=y)\n      amin <- tt[y==min(y)] #abcisse du min\n      if (length(amin)>1) {amin<-amin[length(amin)]}\n      y <- y[amin:(length(y))]\n      tt <- seq(along=y)\n      alN <- tt[(y-(max(y)+min(y))/2)^2==min((y-(max(y)+min(y))/2)^2)] # on cherche la valeur la plus proche de la moyenne des extremes (max(y)+min(y))/2\n      if  (length(alN>1)) {alN<-alN[1]}\n      alN<-amin+alN\n\n\n      ## Limite infÃ©rieur de BT\n      #### Attention pbm dans les amin et amax entre le 1er\n      y <- profil.cerne.0.NA\n      y <- y[amin:alN]\n      # aaa<-aaa+1\n      tt <- seq(along=y)\n      lll <- length(y)\n      amaxt <- tt[y==max(y)] #abcisse du max\n      ttt <- amaxt/lll\n      if (length(amaxt)>1) {amaxt<-amaxt[1]}\n      y <- y[1:(amaxt)]\n      tt <- seq(along=y)\n      amint <- tt[y==min(y)] #abcisse du min\n      if (length(amint)>1) {amint<-amint[length(amint)]}\n      y <- y[amint:(length(y))]\n      tt <- seq(along=y)\n      albti <- tt[(y-(max(y)+min(y))/2)^2==min((y-(max(y)+min(y))/2)^2)]\n      if (length(alN>1)) {albti<-albti[1]}\n      albti <- lim.cernes[k]+amin+albti\n\n      ## Limite superieur de BT\n      y <- profil.cerne.0.NA\n      y <- y[(amin + alN):(length(y))]\n      # aaa <- aaa+1\n      tt <- seq(along=y)\n      lll <- length(y)\n      amaxt <- tt[y==max(y)] #abcisse du max\n      ttt <- amaxt/lll\n      if (length(amaxt)>1) {amaxt<-amaxt[1]}\n      y <- y[1:(amaxt)]\n      tt <- seq(along=y)\n      amint <- tt[y==min(y)] #abcisse du min\n      if (length(amint)>1) {amint<-amint[length(amint)]}\n      y <- y[amint:(length(y))]\n      tt <- seq(along=y)\n      albts <- tt[(y-(max(y)+min(y))/2)^2==min((y-(max(y)+min(y))/2)^2)]\n      if (length(alN>1)) {albts<-albts[1]}\n      albts <- lim.cernes[k]+alN+albts\n\n      # }\n      lim.bibf.Nancy <- c(lim.bibf.Nancy,albti,albts)\n    }\n\n    #           Affichage du profil complet avec l'emplacement des limites ponctuelles\n    #           **********************************************************************\n\n\n    plot(x,type=\"n\",xlab=\"Longueur (X24 microns)\",ylab=\"densite (g/dm3)\", main = profil)\n    lines(x)\n    mtext(\"Definition des limites bois initial-bois final\",3,outer=T,cex=1.4)\n    points(lim.bibf.Nancy,x[lim.bibf.Nancy],type=\"p\",pch=0,cex=1)\n    abline(v=lim.bibf.Nancy,lty=2)\n    abline(v=lim.cernes,lty=1)\n    xxx <- length(x)/50\n    yyy <- min(x,na.rm=T)+0.1*min(x,na.rm=T)\n\n    #readline()\n    #                     SORTIE: profil avec limites\n    #                     ***************************\n\n\n    #controle\n    if (length(lim.bibf.Nancy)!= 2 * nbr.cernes)\n    {\n      cat(\"Warning!\",liste.profils[[i]])\n      readline()\n    }\n    #Profil complet:\n    cat(paste(length(lim.cernes),\"// \"))\n    sortie <- list(length=4) #au lieu de 5 : pas de profil\n    sortie[[1]] <- xx$profil #lim de cernes\n    sortie[[2]] <- xx$limites[!is.na(xx$limites)]\n    sortie[[3]] <- sort(lim.bibf.Nancy) #lim bibf type Nancy (moy min max) ATTENTION en 5 depuis les epiceas Geniality\n    sortie[[4]] <- xx$millesimes[!is.na(xx$millesimes)]\n    names(sortie) <- c(\"profil\",\"lim.cernes\",\"lim.bibtbf\",\"millesimes\")#\n    cat(\"Suivant?\")\n    readline()\n    assign(paste(\"t\",profil,sep=\"\"),sortie,pos=1,immediate=T) #changer\n\n    cat(\"\\nFIN:\\n\")\n\n    #cat(\"\\nTaper <Entree> pour continuer, x pour arreter\\n\")\n    #zzz<-readline()\n    zzz<-\"bouclage\"\n    if (zzz==\"x\") {stop()}\n\n  } #fin de boucle \"automatisation de la lecture des profils d'un .Data\"\n\n} #fin de fonction\n\n",
    "created" : 1494575675389.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2697279536",
    "id" : "AB07C10F",
    "lastKnownWriteTime" : 1516624684,
    "last_content_update" : 1516624684876,
    "path" : "D:/thchauvin/Doc-INRA/Stats R/Packages/MicrodensiteR/R/k.bibtbf.R",
    "project_path" : "R/k.bibtbf.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}